#|==============================================================================

Unsigned Integer Operations - v3.02

Author: Alec Dee - alecdee.github.io - akdee144@gmail.com

--------------------------------------------------------------------------------
About

This library provides functions for performing most of the common unsigned
integer operations. In particular, it handles comparisons, arithmetic
operations, and bitwise operations.

The 0 address will always be 0 upon function return, even if one of the return
value addresses is 0.

This library does not depend on any other libraries.

Average instructions per function:
cmp: 28
set: 24
neg: 25
add: 30
sub: 31
mul: 869
div: 911
shl: 83
shr: 131
not: 26
and: 676
 or: 676
xor: 676

--------------------------------------------------------------------------------
Index

Comparisons
uint.cmp a b lt eq gt

Integer Arithmetic
uint.set ret a
uint.neg ret a
uint.add ret a b
uint.sub ret a b
uint.mul high low a b
uint.div quot rem num den

Bitwise Arithmetic
uint.shl ret a shift
uint.shr ret a shift
uint.not ret a
uint.and ret a b
uint.or  ret a b
uint.xor ret a b

--------------------------------------------------------------------------------
TODO

Optimize uint.mul if high=0, and uint.div if quot=0. Add tests.
Test uint.mul for correctness for all inputs, mod 256.
|#

#--------------------------------------------------------------------------------
#Comparisons

uint.cmp:
	#Call  : 0 ? uint.cmp a b lt eq gt
	#Effect:
	#     if [a]<[b]: goto lt
	#     if [a]=[b]: goto eq
	#     if [a]>[b]: goto gt
	.z  .a2   ?+1
	0   .z    ?+1
	0   .z+2  ?+1
	.a2 0     ?+1
	.a3 0     ?+1
	.a4 0     ?+1
	.a5 0     ?+1
	.a6 0     ?+1
	0   0     ?+1
	#get [a]
	.z  .z    ?+1
	.z  .a2:2 ?+1
	.p0 .p0   ?+1
	.p0 .z    ?+1
	.z  .z    ?+1
	.z  .p0:0 ?+1
	.a  .a    ?+1
	.a  .z    ?+1
	#get [b]
	.z  .z    ?+1
	.z  .a3:3 ?+1
	.b  .b    ?+1
	.b  .z    ?+1
	#[a]-[b]
	.z  .z    ?+1
	.a  .b:0  .le
	#[a]>[b]
	.z  .a6:6 .ret
.le:
	.a  .z    .eq
	#[a]<[b]
	.z  .a4:4 .ret
.eq:
	#[a]=[b]
	.z  .a5:5 .ret
.ret:
	.r  .r    ?+1
	.r  .z    ?+1
	.z  .z    .r:0
#Variables
.a:0
.z:0 1 2

#--------------------------------------------------------------------------------
#Integer Arithmetic

uint.set:
	#Call  : 0 ? uint.set ret a
	#Effect: [ret]=[a]
	#Setup the stack.
	.tmp  .tmp  ?+1
	.tmp  .a2   ?+1
	0     .tmp  ?+1
	0     .off  ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	#Get [ret]
	.p0   .a2:2 ?+1
	.p1   .p0   ?+1
	.p2   .p0   ?+1
	.tmp  .tmp  ?+1
	.tmp  .p1   ?+1
	.p0   .p0   ?+1
	.p0   .tmp  ?+1
	#Get [a]
	.tmp  .tmp  ?+1
	.tmp  .a3:3 ?+1
	.p3   .p3   ?+1
	.p3   .tmp  ?+1
	#Set [ret]
	.ret  .ret  ?+1
	.ret  .p3:0 ?+1  #[ret]=-[a]
	.p0:0 .p1:0 ?+1
	.p2:0 .ret  ?+1  #[ret]=[a]
	0     0     .a4:4
#Variables
.off:2
.ret:0
.tmp:0

uint.neg:
	#Call  : 0 ? uint.neg ret a
	#Effect: [ret]=-[a]
	#Setup the stack.
	.tmp  .tmp  ?+1
	.tmp  .a2   ?+1
	0     .tmp  ?+1
	0     .off  ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	#Get [ret]
	.tmp  .tmp  ?+1
	.tmp  .a2:2 ?+1
	.p0   .p0   ?+1
	.p0   .tmp  ?+1
	.p1   .p1   ?+1
	.p1   .tmp  ?+1
	#Get [a]
	.tmp  .tmp  ?+1
	.tmp  .a3:3 ?+1
	.p2   .p2   ?+1
	.p2   .tmp  ?+1
	#Set [ret]
	.tmp  .tmp  ?+1
	.tmp  .p0:0 ?+1  #[tmp]=-[ret]
	.tmp  .p2:0 ?+1  #[tmp]=-[ret]-[a]
	.ret  .ret  ?+1
	.ret  .tmp  ?+1  #[ret]=[ret]+[a]
	.p1:0 .ret  ?+1  #[ret]=[ret]-([ret]+[a])=-[a]
	0     0     .a4:4
#Variables
.off:2
.ret:0
.tmp:0

uint.add:
	#Call  : 0 ? uint.add ret a b
	#Effect: [ret]=[a]+[b]
	#Setup the stack.
	.tmp  .tmp  ?+1
	.tmp  .a0   ?+1
	0     .tmp  ?+1
	.a0   0     ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	.a5   0     ?+1
	#Get [ret]
	.p0   .a2:2 ?+1
	.p1   .p0   ?+1
	.p2   .p0   ?+1
	.tmp  .tmp  ?+1
	.tmp  .p1   ?+1
	.p0   .p0   ?+1
	.p0   .tmp  ?+1
	#Get [a]
	.tmp  .tmp  ?+1
	.tmp  .a3:3 ?+1
	.p3   .p3   ?+1
	.p3   .tmp  ?+1
	#Get [b]
	.tmp  .tmp  ?+1
	.tmp  .a4:4 ?+1
	.p4   .p4   ?+1
	.p4   .tmp  ?+1
	#Set [ret]
	.tmp  .tmp  ?+1
	.tmp  .p3:0 ?+1  #[tmp]=-[a]
	.tmp  .p4:0 ?+1  #[tmp]=-[a]-[b]
	.p0:0 .p1:0 ?+1
	.p2:0 .tmp  ?+1  #[ret]=[a]+[b]
	#Return
	0     0     .a5:5
#Variables
.a0:0
.tmp:0
.pt:0

uint.sub:
	#Call  : 0 ? uint.sub ret a b
	#Effect: [ret]=[a]-[b]
	#Setup the stack.
	.tmp  .tmp  ?+1
	.tmp  .a0   ?+1
	0     .tmp  ?+1
	.a0   0     ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	.a5   0     ?+1
	#Get [ret]
	.tmp  .tmp  ?+1
	.tmp  .a2:2 ?+1
	.p0   .p0   ?+1
	.p0   .tmp  ?+1
	.p1   .p1   ?+1
	.p1   .tmp  ?+1
	#Get [a]
	.tmp  .tmp  ?+1
	.tmp  .a3:3 ?+1
	.p2   .p2   ?+1
	.p2   .tmp  ?+1
	#Get [b]
	.tmp  .tmp  ?+1
	.tmp  .a4:4 ?+1
	.p3   .p3   ?+1
	.p3   .tmp  ?+1
	#Set [ret]
	.tmp  .tmp  ?+1
	.tmp  .p0:0 ?+1  #[tmp]=-[ret]
	.tmp  .p3:0 ?+1  #[tmp]=-[ret]-[b]
	.ret  .ret  ?+1
	.ret  .p2:0 ?+1  #[ret]=-[a]
	.ret  .tmp  ?+1  #[ret]=[ret]-[a]+[b]
	.p1:0 .ret  ?+1  #[ret]=[a]-[b]
	#Return
	0     0     .a5:5
#Variables
.a0:0
.ret:0
.tmp:0

uint.mul:
	#Call  : 0 ? uint.mul high low a b
	#Effect:
	#     [high]=([a]*[b])/2^64
	#     [low] =([a]*[b])%2^64
	#Setup stack pointer.
	.tmp  .tmp  ?+1
	.tmp  .a2   ?+1
	0     .tmp  ?+1
	0     .z+2  ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	.a5   0     ?+1
	.a6   0     ?+1
	#Get high.
	.tmp  .tmp  ?+1
	.tmp  .a2:2 ?+1
	.r0   .r0   ?+1
	.r0   .tmp  ?+1
	.r1   .r1   ?+1
	.r1   .tmp  ?+1
	#Get low.
	.tmp  .tmp  ?+1
	.tmp  .a3:3 ?+1
	.r2   .r2   ?+1
	.r2   .tmp  ?+1
	.r3   .r3   ?+1
	.r3   .tmp  ?+1
	#Get [a]. Use -[a] for adding to [rl].
	.tmp  .tmp  ?+1
	.tmp  .a4:4 ?+1
	.p0   .p0   ?+1
	.p0   .tmp  ?+1
	.a    .a    ?+1
	.a    .p0:0 ?+1
	#Get [b].
	.tmp  .tmp  ?+1
	.tmp  .a5:5 ?+1
	.p1   .p1   ?+1
	.p1   .tmp  ?+1
	.tmp  .tmp  ?+1
	.tmp  .p1:0 ?+1
	.b    .b    ?+1
	.b    .tmp  ?+1
	#Init rl and rh.
	.rh   .rh   ?+1
	.rl   .rl   ?+1
	#If [a]=0 or [b]=0, return.
	.a    .z    .ret
	.b    .z    .ret
	#Increment [rl] for the first loop.
	.rl   .z-1  ?+1
	.i    .bits ?+1
.loop:
	#If the highest bit of [b] is set, add [a] to [rl] and carry to [rh].
	.tmp  .tmp  ?+1
	.tmp  .b    ?+1
	.tmp  .z+1  ?+1
	.b    .tmp  ?+7
	.rl   .a    ?+4
	.rh   .z-1  ?+1
	#Check loop.
	.i    .z+1  .correct
	#Left shift [rh] and [rl], don't decrement [rl] for when we add [a] to [rl].
	.tmp  .tmp  ?+1
	.tmp  .rh   ?+1
	.rh   .tmp  ?+1
	.tmp  .tmp  ?+1
	.tmp  .rl   ?+1
	.tmp  .z+1  ?+1
	.rl   .tmp  .loop
	.rh   .z-1  .loop
.correct:
	#Correct for [rl]+1 each loop.
	.rl   .z-1  ?+1
	.rl   .z    ?+4
	.rh   .z+1  ?+1
.ret:
	#Set [high].
	.rh   .r0:0 ?+1
	.tmp  .tmp  ?+1
	.tmp  .rh   ?+1
	.r1:0 .tmp  ?+1
	#Set [low].
	.rl   .r2:0 ?+1
	.tmp  .tmp  ?+1
	.tmp  .rl   ?+1
	.r3:0 .tmp  ?+1
	0     0     .a6:6
#Variables
.tmp:0
.a:0
.b:0
.rh:0
.rl:0
.i:0
.bits:0-64
0-1 .z:0 1 2

uint.div:
	#Call  : 0 ? uint.div quot rem num den
	#Effect:
	#     [quot]=[num]/[den], rounded down
	#     [rem] =[num]%[den]
	#Setup stack pointer.
	.tmp  .tmp  ?+1
	.tmp  .a2   ?+1
	0     .tmp  ?+1
	0     .z+2  ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	.a5   0     ?+1
	.a6   0     ?+1
	#Get quotient.
	.tmp  .tmp  ?+1
	.tmp  .a2:2 ?+1
	.r0   .r0   ?+1
	.r0   .tmp  ?+1
	.r1   .r1   ?+1
	.r1   .tmp  ?+1
	#Get remainder.
	.tmp  .tmp  ?+1
	.tmp  .a3:3 ?+1
	.r2   .r2   ?+1
	.r2   .tmp  ?+1
	.r3   .r3   ?+1
	.r3   .tmp  ?+1
	#Get numerator.
	.tmp  .tmp  ?+1
	.tmp  .a4:4 ?+1
	.p0   .p0   ?+1
	.p0   .tmp  ?+1
	.tmp  .tmp  ?+1
	.tmp  .p0:0 ?+1
	.num  .num  ?+1
	.num  .tmp  ?+1
	#Get denominator.
	.tmp  .tmp  ?+1
	.tmp  .a5:5 ?+1
	.p1   .p1   ?+1
	.p1   .tmp  ?+1
	.nden .nden ?+1
	.nden .p1:0 ?+1
	#If [den]=0, abort
	.nden .z    .divz
	.nden .z-1  ?+1
	.den  .den  ?+1
	.den  .nden ?+1
	#Start loop.
	.quot .quot ?+1
	.rem  .rem  ?+1
	.i    .bits ?+1
.loop:
	#[rem]+=[num]>>63, [num]<<=1
	.tmp  .tmp  ?+1
	.tmp  .num  ?+1
	.tmp  .z+1  ?+1
	.num  .tmp  ?+4
	.rem  .z-1  ?+1
	#if [rem]>=[den], [quot]+=1
	.rem  .den  ?+7
	.rem  .z+1  ?+1
	.quot .z-1  ?+4
	.rem  .nden ?+1
	.i    .z+1  .ret
	#[quot]<<=1
	.tmp  .tmp  ?+1
	.tmp  .quot ?+1
	.quot .tmp  ?+1
	#[rem]<<=1
	.tmp  .tmp  ?+1
	.tmp  .rem  ?+1
	.rem  .tmp  .loop
.ret:
	#Set quotient.
	.quot .r0:0 ?+1
	.tmp  .tmp  ?+1
	.tmp  .quot ?+1
	.r1:0 .tmp  ?+1
	#Set remainder.
	.rem  .r2:0 ?+1
	.tmp  .tmp  ?+1
	.tmp  .rem  ?+1
	.r3:0 .tmp  ?+1
	0     0     .a6:6
.divz:
	#Abort.
	0-1 0 0
.num:0
.den:0
.nden:0
.quot:0
.rem:0
.tmp:0
.i:0
.bits:0-64
0-1 .z:0 1 2

#--------------------------------------------------------------------------------
#Bitwise Arithmetic

uint.shl:
	#Call  : 0 ? uint.shl ret a s
	#Effect: [ret]=[a]<<[s]
	#Setup stack pointer.
	.z    .a0   ?+1
	0     .z    ?+1
	.z    .z    ?+1
	.a0   0     ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	.a5   0     ?+1
	#Get ret.
	.z    .a2:2 ?+1
	.r0   .r0   ?+1
	.r0   .z    ?+1
	.r1   .r1   ?+1
	.r1   .z    ?+1
	.z    .z    ?+1
	#Get [a]
	.z    .a3:3 ?+1
	.p0   .p0   ?+1
	.p0   .z    ?+1
	.z    .z    ?+1
	.a    .a    ?+1
	.a    .p0:0 ?+1  #[a]=-[a]
	#Get [s]
	.z    .a4:4 ?+1
	.p1   .p1   ?+1
	.p1   .z    ?+1
	.z    .z    ?+1
	.z    .p1:0 ?+1
	.s    .s    ?+1
	.s    .z    ?+1
	.z    .z    ?+1
	#If [s]<64.
	.s    .bits0 ?+4
	.a    .a     .ret
	.s    .bits1 ?+1
.loop:
	.s    .z+1  .ret
	.z    .a    ?+1
	.a    .z    ?+1
	.z    .z    .loop
.ret:
	#Set [ret].
	.z    .r0:0 ?+1
	.a    .z    ?+1
	.r1:0 .a    ?+1
	.z    .z    ?+1
	0     0     .a5:5
#Variables
.a:0
.s:0
.bits0:64
.bits1:0-65
.a0:0
.z:0 1

uint.shr:
	#Call  : 0 ? uint.shr ret a s
	#Effect: [ret]=[a]>>[s]
	#Setup stack pointer.
	.z    .a0   ?+1
	0     .z    ?+1
	.z    .z    ?+1
	.a0   0     ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	.a5   0     ?+1
	#Get ret
	.z    .a2:2 ?+1
	.r0   .r0   ?+1
	.r0   .z    ?+1
	.r1   .r1   ?+1
	.r1   .z    ?+1
	.z    .z    ?+1
	.r    .r    ?+1
	#Get [a]
	.z    .a3:3 ?+1
	.p0   .p0   ?+1
	.p0   .z    ?+1
	.z    .z    ?+1
	.z    .p0:0 ?+1
	.a    .a    ?+1
	.a    .z    ?+1
	.z    .z    ?+1
	#Get [s]
	.z    .a4:4 ?+1
	.p1   .p1   ?+1
	.p1   .z    ?+1
	.z    .z    ?+1
	.s    .s    ?+1
	.s    .bits ?+1
	#If [s]>=64.
	.s    .p1:0 .ret
.loop:
	.z    .a    ?+1
	.z    .z+1  ?+1
	.a    .z    ?+4
	.r    .z-1  ?+1
	.z    .z    ?+1
	.s    .z+1  .ret
	.z    .r    ?+1
	.r    .z    ?+1
	.z    .z    .loop
.ret:
	#Set [ret].
	.r    .r0:0 ?+1
	.z    .r    ?+1
	.r1:0 .z    ?+1
	.z    .z    ?+1
	0     0     .a5:5
#Variables
.a:0
.r:0
.s:0
.bits:0-64
.a0:0
0-1 .z:0 1

uint.not:
	#Call  : 0 ? uint.not ret a
	#Effect: [ret]=~[a]
	#Use the relation -1-[a]=~[a]
	#Setup the stack.
	.tmp  .tmp  ?+1
	.tmp  .a2   ?+1
	0     .tmp  ?+1
	0     .z+2  ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	#Get [ret]
	.tmp  .tmp  ?+1
	.tmp  .a2:2 ?+1
	.p0   .p0   ?+1
	.p0   .tmp  ?+1
	.p1   .p1   ?+1
	.p1   .tmp  ?+1
	#Get [a]
	.tmp  .tmp  ?+1
	.tmp  .a3:3 ?+1
	.p2   .p2   ?+1
	.p2   .tmp  ?+1
	#Set [ret]
	.tmp  .tmp  ?+1
	.tmp  .p0:0 ?+1  #[tmp]=-[ret]
	.tmp  .p2:0 ?+1  #[tmp]=-[ret]-[a]
	.tmp  .z+1  ?+1
	.ret  .ret  ?+1
	.ret  .tmp  ?+1  #[ret]=[ret]+[a]
	.p1:0 .ret  ?+1  #[ret]=[ret]-([ret]+[a])=-[a]
	0     0     .a4:4
#Variables
.z:0 1 2
.ret:0
.tmp:0

uint.and:
	#Call  : 0 ? uint.and ret a b
	#Effect: [ret]=[a]&[b]
	#Setup stack pointer.
	.at   .at   ?+1
	.at   .a0   ?+1
	0     .at   ?+1
	.a0   0     ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	.a5   0     ?+1
	#Get [r]
	.at   .at   ?+1
	.at   .a2:2 ?+1
	.r0   .r0   ?+1
	.r0   .at   ?+1
	.r1   .r1   ?+1
	.r1   .at   ?+1
	#Get [a]
	.at   .at   ?+1
	.at   .a3:3 ?+1
	.p0   .p0   ?+1
	.p0   .at   ?+1
	.a    .a    ?+1
	.a    .z+1  ?+1
	.a    .p0:0 ?+1
	#Get [b]
	.at   .at   ?+1
	.at   .a4:4 ?+1
	.p1   .p1   ?+1
	.p1   .at   ?+1
	.b    .b    ?+1
	.b    .z+1  ?+1
	.b    .p1:0 ?+1
	#Loop 64 times.
	.at   .at   ?+1
	.i    .bits ?+1
.loop:
	.i    .z+1  .ret
	#Prepare [a] for shift and carry.
	.at   .a    ?+1
	.at   .z+1  ?+1
	#Prepare [b] for shift and carry.
	.bt   .bt   ?+1
	.bt   .b    ?+1
	.bt   .z+1  ?+1
	#Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	      .a .at  .f0x
	.f1x: .b .bt  .f10
	.f11: .a .z+1 ?+1 .at .at .loop
	.f10: .a .z+1 ?+1 .at .at .loop
	.f0x: .b .bt  .f00
	.f01: .a .z+1 ?+1 .at .at .loop
	.f00: .a .z+0 ?+1 .at .at .loop
.ret:
	.a    .r0:0 ?+1
	.at   .a    ?+1
	.r1:0 .at   ?+1
	0 0 .a5:5
#Variables
.a:0 .at:0
.b:0 .bt:0
.i:0
.a0:0
.bits:0-65
0-1 .z:0 1

uint.or:
	#Call  : 0 ? uint.or ret a b
	#Effect: [ret]=[a]|[b]
	#Setup stack pointer.
	.at   .at   ?+1
	.at   .a0   ?+1
	0     .at   ?+1
	.a0   0     ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	.a5   0     ?+1
	#Get [r]
	.at   .at   ?+1
	.at   .a2:2 ?+1
	.r0   .r0   ?+1
	.r0   .at   ?+1
	.r1   .r1   ?+1
	.r1   .at   ?+1
	#Get [a]
	.at   .at   ?+1
	.at   .a3:3 ?+1
	.p0   .p0   ?+1
	.p0   .at   ?+1
	.a    .a    ?+1
	.a    .z+1  ?+1
	.a    .p0:0 ?+1
	#Get [b]
	.at   .at   ?+1
	.at   .a4:4 ?+1
	.p1   .p1   ?+1
	.p1   .at   ?+1
	.b    .b    ?+1
	.b    .z+1  ?+1
	.b    .p1:0 ?+1
	#Loop 64 times.
	.at   .at   ?+1
	.i    .bits ?+1
.loop:
	.i    .z+1  .ret
	#Prepare [a] for shift and carry.
	.at   .a    ?+1
	.at   .z+1  ?+1
	#Prepare [b] for shift and carry.
	.bt   .bt   ?+1
	.bt   .b    ?+1
	.bt   .z+1  ?+1
	#Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	      .a .at  .f0x
	.f1x: .b .bt  .f10
	.f11: .a .z+1 ?+1 .at .at .loop
	.f10: .a .z+0 ?+1 .at .at .loop
	.f0x: .b .bt  .f00
	.f01: .a .z+0 ?+1 .at .at .loop
	.f00: .a .z+0 ?+1 .at .at .loop
.ret:
	.a    .r0:0 ?+1
	.at   .a    ?+1
	.r1:0 .at   ?+1
	0 0 .a5:5
#Variables
.a:0 .at:0
.b:0 .bt:0
.i:0
.a0:0
.bits:0-65
0-1 .z:0 1

uint.xor:
	#Call  : 0 ? uint.xor ret a b
	#Effect: [ret]=[a]^[b]
	#Setup stack pointer.
	.at   .at   ?+1
	.at   .a0   ?+1
	0     .at   ?+1
	.a0   0     ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	.a5   0     ?+1
	#Get [r]
	.at   .at   ?+1
	.at   .a2:2 ?+1
	.r0   .r0   ?+1
	.r0   .at   ?+1
	.r1   .r1   ?+1
	.r1   .at   ?+1
	#Get [a]
	.at   .at   ?+1
	.at   .a3:3 ?+1
	.p0   .p0   ?+1
	.p0   .at   ?+1
	.a    .a    ?+1
	.a    .z+1  ?+1
	.a    .p0:0 ?+1
	#Get [b]
	.at   .at   ?+1
	.at   .a4:4 ?+1
	.p1   .p1   ?+1
	.p1   .at   ?+1
	.b    .b    ?+1
	.b    .z+1  ?+1
	.b    .p1:0 ?+1
	#Loop 64 times.
	.at   .at   ?+1
	.i    .bits ?+1
.loop:
	.i    .z+1  .ret
	#Prepare [a] for shift and carry.
	.at   .a    ?+1
	.at   .z+1  ?+1
	#Prepare [b] for shift and carry.
	.bt   .bt   ?+1
	.bt   .b    ?+1
	.bt   .z+1  ?+1
	#Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	      .a .at  .f0x
	.f1x: .b .bt  .f10
	.f11: .a .z+1 ?+1 .at .at .loop
	.f10: .a .z+0 ?+1 .at .at .loop
	.f0x: .b .bt  .f00
	.f01: .a .z+0 ?+1 .at .at .loop
	.f00: .a .z+1 ?+1 .at .at .loop
.ret:
	.a    .r0:0 ?+1
	.at   .a    ?+1
	.r1:0 .at   ?+1
	0 0 .a5:5
#Variables
.a:0 .at:0
.b:0 .bt:0
.i:0
.a0:0
.bits:0-65
0-1 .z:0 1

