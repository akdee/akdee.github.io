#|==============================================================================

Unsigned Integer Testing - v1.00

Author: Alec Dee - alecdee.github.io - akdee144@gmail.com

--------------------------------------------------------------------------------
About

To compile the necessary files together, run
cat uinttest.unl uint.unl print.unl > uint_test_compiled.unl
./unileq uint_test_compiled.unl

Average instructions per function
cmp: 28
set: 24
neg: 25
add: 30
sub: 31
mul: 933
div: 978
shl: 81
shr: 130
not: 26
and: 676
 or: 676
xor: 676

--------------------------------------------------------------------------------
TODO

time: 1.530
Better handling of A=-1 in test.measure.
Simplify random number generation:
	test.rand.mod takes 532 instructions
	test.rand.uint takes 36000 instructions. 65*532=34580.
|#

0 0 test.main

test.main:
	#Starting integer tests.
	0 ? print 115 116 97 114 116 105 110 103 32 105 110 116 101 103 101 114 32 116 101 115 116 115 10 0

.loop:
	#While trial<trials.
	.tmp0 .tmp0 ?+1
	.tmp0 .trials ?+1
	.tmp1 .tmp1 ?+1
	.tmp1 .tmp0 ?+1
	.tmp1 .trial .done

	#---------------------- Parameters ----------------------
	#Generate A, B, and C parameters.
	0 ? test.rand.uint .a
	0 ? test.rand.uint .b
	0 ? test.rand.mod  .c .shiftmax
	.c .shiftsub ?+1

	#Randomly set A=B.
	0 ? test.rand.mod  .tmp0 .eqprob
	.tmp0 .z    ?+4
	.tmp0 .tmp0 .nosetab
	.tmp0 .b    ?+1
	.a    .a    ?+1
	.a    .tmp0 ?+1
	.nosetab:

	#Copy A, B, and C to compare later.
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.a0   .a0   ?+1
	.a0   .tmp0 ?+1
	.tmp0 .tmp0 ?+1
	.tmp0 .b    ?+1
	.b0   .b0   ?+1
	.b0   .tmp0 ?+1
	.tmp0 .tmp0 ?+1
	.tmp0 .c    ?+1
	.c0   .c0   ?+1
	.c0   .tmp0 ?+1

	#0 ? print 0-1 .trial 32 0-1 .a 32 0-1 .b 32 0-1 .c 10 0

	#----------------------- Compare ------------------------
	#Compare A and B manually.
	.exp0 .exp0 ?+1
	.exp0 .z-1  ?+1
	.b    .a    ?+4
	.exp0 .z+1  ?+7
	.b    .z    ?+4
	.exp0 .z-1  ?+1
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.b    .tmp0 ?+1

	.ret0 .ret0 ?+1
	0 ? test.measure .cmpops .cmplt 0 ? uint.cmp .a .b .cmplt .cmpeq .cmpgt
	0-1 0 0
	.cmpgt: .ret0   .z-1  ?+1
	.cmpeq: .ret0   .z-1  ?+1
	.cmplt: .cmpops .ret0 ?+1
	0 ? test.cmp .exp0 .ret0 0

	#------------------------- Set --------------------------
	0 ? test.measure .setops ?+6 0 ? uint.set .ret0 .a
	0 ? test.cmp .a .ret0 1

	#----------------------- Negation -----------------------
	#Calculate -A manually.
	.exp0 .exp0 ?+1
	.exp0 .a    ?+1

	0 ? test.measure .negops ?+6 0 ? uint.neg .ret0 .a
	0 ? test.cmp .exp0 .ret0 2

	#----------------------- Addition -----------------------
	#Calculate A+B manually.
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.tmp0 .b    ?+1
	.exp0 .exp0 ?+1
	.exp0 .tmp0 ?+1

	0 ? test.measure .addops ?+7 0 ? uint.add .ret0 .a .b
	0 ? test.cmp .exp0 .ret0 3

	#--------------------- Subtraction ----------------------
	#Calculate A-B manually.
	.exp0 .b    ?+1
	.exp0 .b    ?+1

	0 ? test.measure .subops ?+7 0 ? uint.sub .ret0 .a .b
	0 ? test.cmp .exp0 .ret0 4

	#-------------------- Multiplication --------------------
	#Calculate A*B manually.
	.exp0 .exp0 ?+1
	#[tmp1]=[a]
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.tmp1 .tmp1 ?+1
	.tmp1 .tmp0 ?+1
	#[tmp2]=65
	.tmp2 .tmp2 ?+1
	.tmp2 .nbits-1 ?+1
	.mulloop:
	.tmp2 .z+1  .muldone
	#exp<<=1
	.tmp0 .tmp0 ?+1
	.tmp0 .exp1 ?+1
	.exp1 .tmp0 ?+1
	.tmp0 .tmp0 ?+1
	.tmp0 .exp0 ?+1
	.tmp0 .z+1  ?+1
	.exp0 .tmp0 ?+4
	#If [exp0] carries.
	.exp1 .z-1  ?+1
	.exp0 .z+1  ?+1
	#[tmp1]<<=1
	.tmp0 .tmp0 ?+1
	.tmp0 .tmp1 ?+1
	.tmp0 .z+1  ?+1
	.tmp1 .tmp0 .mulloop
	#[exp0]+=[b]
	.tmp0 .tmp0 ?+1
	.tmp0 .b    ?+1
	.tmp0 .z+1  ?+1
	.exp0 .tmp0 ?+4
	.exp1 .z-1  ?+1
	.exp0 .z+1  ?+1
	.tmp0 .tmp0 .mulloop
	.muldone:

	0 ? test.measure .mulops ?+8 0 ? uint.mul .ret1 .ret0 .a .b
	0 ? test.cmp .exp0 .ret0 5
	0 ? test.cmp .exp1 .ret1 6

	#----------------------- Division -----------------------
	#For B!=0, q=A/B, and r=A%B, we have A=q*B+r and r<B.
	.b .z .div0
	.divden .z-1 ?+1
	0 ? test.measure .divops ?+8 0 ? uint.div .ret0 .ret1 .a .b
	0 ? uint.cmp .ret1 .b .remlt ?+2 ?+1
	0 ? test.cmp .z .b 7
	.remlt:
	0 ? uint.mul .tmp0 .tmp1 .ret0 .b
	0 ? test.cmp .z .tmp0 8
	0 ? uint.add .tmp1 .ret1 .tmp1
	0 ? test.cmp .a .tmp1 9
	.div0:

	#---------------------- Shift Left ----------------------
	#Calculate A<<C manually.
	#[exp0]=[a]
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.exp0 .exp0 ?+1
	.exp0 .tmp0 ?+1
	#[tmp2]=-[c]
	.tmp2 .tmp2 ?+1
	.tmp2 .c    ?+1
	.shlloop:
	.exp0 .z    .shldone
	.tmp2 .z    .shldone
	.tmp0 .tmp0 ?+1
	.tmp0 .exp0 ?+1
	.exp0 .tmp0 ?+1
	.tmp2 .z-1  .shlloop
	.shldone:

	0 ? test.measure .shlops ?+7 0 ? uint.shl .ret0 .a .c
	0 ? test.cmp .exp0 .ret0 10

	#--------------------- Shift Right ----------------------
	#Calculate A>>C manually.
	.exp0 .exp0 ?+1
	#[tmp1]=[a]
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.tmp1 .tmp1 ?+1
	.tmp1 .tmp0 ?+1
	#[tmp2]=-[c]-1
	.tmp2 .tmp2 ?+1
	.tmp2 .c    ?+1
	.tmp2 .z+1  ?+1
	.shrloop:
	.tmp2 .nbits-1 .shrdone
	.tmp2 .bits+2 ?+1
	#[exp0]<<=1
	.tmp0 .tmp0 ?+1
	.tmp0 .exp0 ?+1
	.exp0 .tmp0 ?+1
	#[tmp1]<<=1
	.tmp0 .tmp0 ?+1
	.tmp0 .tmp1 ?+1
	.tmp0 .z+1  ?+1
	.tmp1 .tmp0 .shrloop
	.exp0 .z-1  .shrloop
	.shrdone:

	0 ? test.measure .shrops ?+7 0 ? uint.shr .ret0 .a .c
	0 ? test.cmp .exp0 .ret0 11

	#------------------------- Not --------------------------
	#~A=-1-A
	.exp0 .exp0 ?+1
	.exp0 .z+1  ?+1
	.exp0 .a    ?+1

	0 ? test.measure .notops ?+6 0 ? uint.not .ret0 .a
	0 ? test.cmp .exp0 .ret0 12

	#------------------------- And --------------------------
	#Calculate A&B manually.
	#[exp0]=[a]
	.tmp0 .tmp0 ?+1
	.tmp0 .a    ?+1
	.exp0 .exp0 ?+1
	.exp0 .tmp0 ?+1
	#[exp1]=[b]
	.tmp0 .tmp0 ?+1
	.tmp0 .b    ?+1
	.exp1 .exp1 ?+1
	.exp1 .tmp0 ?+1
	#[tmp2]=65
	.tmp2 .tmp2 ?+1
	.tmp2 .nbits-1 ?+1
	.andloop:
	.tmp2 .z+1  .anddone
	#[exp0]<<=1
	.tmp0 .tmp0 ?+1
	.tmp0 .exp0 ?+1
	.exp0 .tmp0 ?+1
	#[exp1]<<=1
	.tmp1 .tmp1 ?+1
	.tmp1 .exp1 ?+1
	.tmp1 .z+1  ?+1
	#Set [exp0] if both carry.
	.exp1 .tmp1 .andloop
	.tmp0 .z    .andloop
	.tmp0 .hbit ?+4
	.tmp0 .tmp0 .andloop
	.exp0 .z-1  .andloop
	.anddone:

	0 ? test.measure .andops ?+7 0 ? uint.and .ret0 .a .b
	0 ? test.cmp .exp0 .ret0 13

	#-------------------------- Or --------------------------
	#A|B=A+B-(A&B)
	.ret0 .a    ?+1
	.ret0 .b    ?+1
	.exp1 .exp1 ?+1
	.exp1 .ret0 ?+1

	0 ? test.measure .orops ?+7 0 ? uint.or .ret0 .a .b
	0 ? test.cmp .exp1 .ret0 14

	#------------------------- Xor --------------------------
	#A^B=(A|B)-(A&B)
	.exp1 .exp0 ?+1

	0 ? test.measure .xorops ?+7 0 ? uint.xor .ret0 .a .b
	0 ? test.cmp .exp1 .ret0 15

	#Make sure parameters haven't been modified.
	0 ? test.cmp .a0 .a 16
	0 ? test.cmp .b0 .b 17
	0 ? test.cmp .c0 .c 18

	.trial .z-1 .loop

.done:
	#Print instruction counts.
	0 ? uint.div .cmpops 0 .cmpops .trial
	0 ? uint.div .setops 0 .setops .trial
	0 ? uint.div .negops 0 .negops .trial
	0 ? uint.div .addops 0 .addops .trial
	0 ? uint.div .subops 0 .subops .trial
	0 ? uint.div .mulops 0 .mulops .trial
	0 ? uint.div .divops 0 .divops .divden
	0 ? uint.div .shlops 0 .shlops .trial
	0 ? uint.div .shrops 0 .shrops .trial
	0 ? uint.div .notops 0 .notops .trial
	0 ? uint.div .andops 0 .andops .trial
	0 ? uint.div  .orops 0  .orops .trial
	0 ? uint.div .xorops 0 .xorops .trial
	0 ? print 97 118 101 114 97 103 101 32 105 110 115 116 114 117 99 116 105 111
	          110 115 32 112 101 114 32 102 117 110 99 116 105 111 110 10 0
	0 ? print  99 109 112 58 32 0-1 .cmpops 10 0
	0 ? print 115 101 116 58 32 0-1 .setops 10 0
	0 ? print 110 101 103 58 32 0-1 .negops 10 0
	0 ? print  97 100 100 58 32 0-1 .addops 10 0
	0 ? print 115 117  98 58 32 0-1 .subops 10 0
	0 ? print 109 117 108 58 32 0-1 .mulops 10 0
	0 ? print 100 105 118 58 32 0-1 .divops 10 0
	0 ? print 115 104 108 58 32 0-1 .shlops 10 0
	0 ? print 115 104 114 58 32 0-1 .shrops 10 0
	0 ? print 110 111 116 58 32 0-1 .notops 10 0
	0 ? print  97 110 100 58 32 0-1 .andops 10 0
	0 ? print  32 111 114 58 32 0-1  .orops 10 0
	0 ? print 120 111 114 58 32 0-1 .xorops 10 0
	0 ? print 112 97 115 115 101 100 10 0
	0-1 0 0
0-1 .z:0 1
.a:0
.b:0
.c:0
.eqprob:64
.shiftmax:181
.shiftsub:66
.cmpops:0
.setops:0
.negops:0
.addops:0
.subops:0
.mulops:0
.divops:0
.divden:0
.shlops:0
.shrops:0
.notops:0
.andops:0
.orops:0
.xorops:0
.trial:0
.trials:2048
.exp0:0
.exp1:0
.ret0:0
.ret1:0
.tmp0:0
.tmp1:0
.tmp2:0
#Place these far away from .a, .b, and .c in order to minimize accidental use
#by functions.
.a0:0
.b0:0
.c0:0
.hbit:0x8000000000000000
0-65 .nbits:0-64
.bits:64 65 66

test.rand.mod:
	#Call  : 0 ? test.rand.mod ret mod
	#Effect: [ret]=(rand)%[mod]
	#Setup new stack.
	.tmp0 .tmp0 ?+1
	.tmp0 .p0   ?+1
	0     .z+2  ?+1
	0     .tmp0 ?+1
	.p0   0     ?+1
	.p1   0     ?+1
	.addr 0     ?+1
	#Get [ret]
	.tmp0 .tmp0 ?+1
	.tmp0 .p0:0 ?+1
	.p5   .p5   ?+1
	.p5   .tmp0 ?+1
	.p6   .p6   ?+1
	.p6   .tmp0 ?+1
	#Get [mod] and -[mod]
	.tmp0 .tmp0 ?+1
	.tmp0 .p1:1 ?+1
	.p2   .p2   ?+1
	.p2   .tmp0 ?+1
	.nmod .nmod ?+1
	.nmod .p2:0 ?+1
	.nmod .z-1  ?+1
	.mod  .mod  ?+1
	.mod  .nmod ?+1
	#[val]=4660046610375530309*[val]+14656126911870262207
	.tmp0 .tmp0 ?+1
	.i    .i0   ?+1
.mul:
	.tmp0 .val  ?+1
	.val  .tmp0 ?+1
	.i    .z-2  .mul
	.val  .inc  ?+1
	#Use top 32 bits of val to compute rand%[mod].
	.rand .rand ?+1
	.tmp1 .tmp1 ?+1
	.tmp1 .val  ?+1
	.tmp0 .tmp0 ?+1
	.tmp0 .tmp1 ?+1
	.i    .i1   ?+1
.shift:
	#[rand]<<=1
	.tmp1 .tmp1 ?+1
	.tmp1 .rand ?+1
	.rand .tmp1 ?+1
	#[tmp0]<<=1, [rand]+=carry
	.tmp1 .tmp1 ?+1
	.tmp1 .tmp0 ?+1
	.tmp1 .z+1  ?+1
	.tmp0 .tmp1 .nocarry
	.rand .z-1  ?+1
.nocarry:
	.rand .mod  .nomod
	.rand .z+1  ?+1
	.rand .mod  ?+1
.nomod:
	.rand .nmod ?+1
	.i    .z-2  .shift
	#Return
	.tmp0 .tmp0 ?+1
	.rand .p5:0 ?+1
	.tmp0 .rand ?+1
	.p6:0 .tmp0 ?+1  #[ret]=[rand]
	0     0     .addr:2
0-2 0-1 .z:0 1 2
.i:1
.i0:90
.i1:64
.tmp0:0
.tmp1:0
.rand:0
.mod:0
.nmod:0
.val:4844720744148949087
.inc:0-14656126911870262207

test.rand.uint:
	#Call  : 0 ? test.rand ret
	#Effect: [ret]=(rand)
	#Generate a random integer such that the probability of any bitcount is uniform.
	#Setup new stack.
	.tmp0 .tmp0 ?+1
	.tmp0 .p0   ?+1
	0     .z+2  ?+1
	0     .tmp0 ?+1
	.p0   0     ?+1
	.addr 0     ?+1
	0     0     ?+1
	#Get [ret]
	.tmp0 .tmp0 ?+1
	.tmp0 .p0:0 ?+1
	.p5   .p5   ?+1
	.p5   .tmp0 ?+1
	.p6   .p6   ?+1
	.p6   .tmp0 ?+1
	#Shuffle arr.
	.i    .i    ?+1
	.i    .p62  ?+1
.shuffle:
	.i    .n64  ?+1
	0 ? test.rand.mod .tmp0 .i
	.i    .z+1  ?+1
	#Setup j swap address.
	.tmp1 .tmp1 ?+1
	.tmp1 .tmp0 ?+1
	.tmp1 .arr0 ?+1
	.j0   .j0   ?+1
	.j0   .tmp1 ?+1
	.j1   .j1   ?+1
	.j1   .tmp1 ?+1
	#Setup i swap address.
	.tmp1 .tmp1 ?+1
	.tmp1 .i    ?+1
	.tmp1 .arr0 ?+1
	.i0   .i0   ?+1
	.i0   .tmp1 ?+1
	.i1   .i1   ?+1
	.i1   .tmp1 ?+1
	#Swap i and j.
	.tmp0 .tmp0 ?+1
	.tmp0 .i0:0 ?+1  #[t0]=-[i]
	.tmp1 .tmp1 ?+1
	.tmp1 .j0:0 ?+1  #[t1]=-[j]
	.tmp1 .tmp0 ?+1  #[t1]=-[j]+[i]
	.i1:0 .tmp1 ?+1  #[i]=[i]+[j]-[i]=[j]
	.tmp0 .tmp0 ?+1
	.tmp0 .tmp1 ?+1  #[t0]=[j]-[i]
	.j1:0 .tmp0 ?+1  #[j]=[j]-[j]+[i]
	.i    .p62  .shuffle
	#Calculate how many bits we want to set.
	.i    .n64  ?+1
	0 ? test.rand.mod .i .i
	.tmp0 .tmp0 ?+1
	.b0   .b0   ?+1
	.b0   .arr1 ?+1
	.i    .z-1  ?+1
.setbits:
	.i    .z+1  .setdone
	.tmp0 .b0:0 ?+1
	.b0   .z-1  .setbits
.setdone:
	#Return
	.tmp1 .tmp1 ?+1
	.tmp1 .p5:0 ?+1
	.tmp0 .tmp1 ?+1
	.p6:0 .tmp0 ?+1  #[ret]=[rand]
	0     0     .addr:1
0-1 .z:0 1 2
.p62:62
.n64:0-64
.tmp0:0
.tmp1:0
.i:0
.arr:
	0x1 0x2 0x4 0x8 0x10 0x20 0x40 0x80 0x100 0x200 0x400 0x800 0x1000 0x2000 0x4000
	0x8000 0x10000 0x20000 0x40000 0x80000 0x100000 0x200000 0x400000 0x800000
	0x1000000 0x2000000 0x4000000 0x8000000 0x10000000 0x20000000 0x40000000
	0x80000000 0x100000000 0x200000000 0x400000000 0x800000000 0x1000000000
	0x2000000000 0x4000000000 0x8000000000 0x10000000000 0x20000000000 0x40000000000
	0x80000000000 0x100000000000 0x200000000000 0x400000000000 0x800000000000
	0x1000000000000 0x2000000000000 0x4000000000000 0x8000000000000 0x10000000000000
	0x20000000000000 0x40000000000000 0x80000000000000 0x100000000000000
	0x200000000000000 0x400000000000000 0x800000000000000 0x1000000000000000
	0x2000000000000000 0x4000000000000000 0x8000000000000000
.arr0:.arr
.arr1:0-.arr

test.cmp:
	#Call  : 0 ? test.cmp exp val id
	#Setup stack.
	.tmp  .tmp  ?+1
	.tmp  .p0   ?+1
	0     .tmp  ?+1
	0     .z+2  ?+1
	.p0   0     ?+1
	.p2   0     ?+1
	.id   0     ?+1
	.ret  0     ?+1
	0     0     ?+1
	#Get [exp]
	.tmp  .tmp  ?+1
	.tmp  .p0:0 ?+1
	.p1   .p1   ?+1
	.p1   .tmp  ?+1
	.tmp  .tmp  ?+1
	.tmp  .p1:0 ?+1
	.exp  .tmp  ?+1
	#Get [val]
	.tmp  .tmp  ?+1
	.tmp  .p2:1 ?+1
	.p3   .p3   ?+1
	.p3   .tmp  ?+1
	.tmp  .tmp  ?+1
	.tmp  .p3:0 ?+1
	.val  .val  ?+1
	.val  .tmp  ?+1
	#Compare [exp] and [val].
	.exp  .val  ?+1
	.exp  .z    .ret:3
	.exp  .tmp  ?+1
	#ERROR
	0 ? print 69 82 82 79 82 10 0
	#line
	0 ? print 116 114 105 97 108 32 58 32 0-1 test.main.trial 10 0
	#test
	0 ? print 116 101 115 116 32 32 58 32 0-1 .id:2 10 0
	#expect
	0 ? print 101 120 112 101 99 116 58 32 0-1 .exp 10 0
	#actual
	0 ? print 97 99 116 117 97 108 58 32 0-1 .val 10 0
	0-1 0 0
.exp:0
.val:0
.z:0 1 2
.tmp:0

test.measure:
	#0 ? test.measure counter return 0 ? func arg0 arg1 ...
	#counter = the address for counting instructions.
	#return  = address the function will return to when finished.
	#Emulates the execution of a function and measures how many instructions it uses.
	#Uses 24+24*n instructions for n emulated instructions.
	.tmp  .a0   ?+1
	.nret .tmp  ?+1
	.tmp  0     ?+1
	.dif  .tmp  ?+1
	.dif  .z+4  ?+1
	#Setup counter.
	0     .z+2  ?+1
	.p0   .p0   ?+1
	.p0   0     ?+1
	.tmp  .tmp  ?+1
	.tmp  .p0:0 ?+1
	.cnt  .cnt  ?+1
	.cnt  .tmp  ?+1
	#Get the negative return address. If [nret]+[dif0]+[dif1]+...=0, then return.
	0     .z+1  ?+1
	.p1   .p1   ?+1
	.p1   0     ?+1
	.nret .p1:0 ?+1
	#Reset stack address.
	0     0     ?+1
.loop:
	#Update a, b, and c addresses.
	.a0   .dif  ?+1
	.b0   .dif  ?+1
	.c0   .dif  ?+1
	.nret .dif  ?+1
	.dif  .dif  ?+1
	#Return if ip=[ret].
	.nret .z    .ret
	#Load [a]. a0 will hold the return address when we're done.
	.tmp  .tmp  ?+2
	.ret: .tmp
	.tmp  .a0:0 ?+1
	.a    .a    ?+1
	.a    .tmp  ?+1
	#Load [b].
	.tmp  .tmp  ?+1
	.tmp  .b0:1 ?+1
	.b    .b    ?+1
	.b    .tmp  ?+1
	#Set [dif]=-[c].
	.dif  .c0:2 ?+1
	.c    .c    ?+1
	#If a=-1, set c=[c0]. Otherwise, set c=jmp.
	.a    .z-2  ?+4
	.c    .dif  ?+4
	.c    .njmp ?+1
	.a    .z+2  ?+1
	#Execute instruction.
	.a:0  .b:0  .c:0
	#We failed to jump, set [dif]=-3.
	.dif  .dif  ?+1
	.dif  .z+3  .cnt
.jmp:
	#We jumped, set [dif]=[a0]-[c].
	.tmp  .tmp  ?+1
	.tmp  .a0   ?+1
	.dif  .tmp  ?+1
.cnt:
	#Increment the instruction counter.
	0     .z-1  .loop
.tmp:0
.nret:0
.dif:0
.njmp:0-.jmp
0-2 0-1 .z:0 1 2 3 4

#|==============================================================================

Unsigned Integer Operations - v3.00

Author: Alec Dee - alecdee.github.io - akdee144@gmail.com

--------------------------------------------------------------------------------
About

This library provides functions for performing most of the common unsigned
integer operations. In particular, it handles comparisons, arithmetic
operations, and bitwise operations.

The 0 address will always be 0 upon function return, even if one of the return
value addresses is 0.

This library does not depend on any other libraries.

Average instructions per function:
cmp: 28
set: 24
neg: 25
add: 30
sub: 31
mul: 933
div: 978
shl: 81
shr: 130
not: 26
and: 676
 or: 676
xor: 676

--------------------------------------------------------------------------------
Index

Comparisons
uint.cmp a b lt eq gt

Integer Arithmetic
uint.set ret a
uint.neg ret a
uint.add ret a b
uint.sub ret a b
uint.mul high low a b
uint.div quot rem num den

Bitwise Arithmetic
uint.shl ret a shift
uint.shr ret a shift
uint.not ret a
uint.and ret a b
uint.or  ret a b
uint.xor ret a b

--------------------------------------------------------------------------------
TODO

Optimize mul if high=0, and div if quot=0.
Add comparisons for jeq, jne, jle, and jl.
Use fibonacci for multiplication and division. Reverse fibonacci works with
unileq. Ex: 55 34 21 13 8 5 3 2 1 1 0
|#

#--------------------------------------------------------------------------------
#Comparisons

uint.cmp:
	#Call  : 0 ? uint.cmp a b lt eq gt
	#Effect:
	#     if [a]<[b]: goto lt
	#     if [a]=[b]: goto eq
	#     if [a]>[b]: goto gt
	.z  .a2   ?+1
	0   .z    ?+1
	0   .z+2  ?+1
	.a2 0     ?+1
	.a3 0     ?+1
	.a4 0     ?+1
	.a5 0     ?+1
	.a6 0     ?+1
	0   0     ?+1
	#get [a]
	.z  .z    ?+1
	.z  .a2:2 ?+1
	.p0 .p0   ?+1
	.p0 .z    ?+1
	.z  .z    ?+1
	.z  .p0:0 ?+1
	.a  .a    ?+1
	.a  .z    ?+1
	#get [b]
	.z  .z    ?+1
	.z  .a3:3 ?+1
	.b  .b    ?+1
	.b  .z    ?+1
	#[a]-[b]
	.z  .z    ?+1
	.a  .b:0  .le
	#[a]>[b]
	.z  .a6:6 .ret
.le:
	.a  .z    .eq
	#[a]<[b]
	.z  .a4:4 .ret
.eq:
	#[a]=[b]
	.z  .a5:5 .ret
.ret:
	.r  .r    ?+1
	.r  .z    ?+1
	.z  .z    .r:0
#Variables
.a:0
.z:0 1 2

#--------------------------------------------------------------------------------
#Integer Arithmetic

uint.set:
	#Call  : 0 ? uint.set ret a
	#Effect: [ret]=[a]
	#Setup the stack.
	.tmp  .tmp  ?+1
	.tmp  .a2   ?+1
	0     .tmp  ?+1
	0     .off  ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	#Get [ret]
	.p0   .a2:2 ?+1
	.p1   .p0   ?+1
	.p2   .p0   ?+1
	.tmp  .tmp  ?+1
	.tmp  .p1   ?+1
	.p0   .p0   ?+1
	.p0   .tmp  ?+1
	#Get [a]
	.tmp  .tmp  ?+1
	.tmp  .a3:3 ?+1
	.p3   .p3   ?+1
	.p3   .tmp  ?+1
	#Set [ret]
	.ret  .ret  ?+1
	.ret  .p3:0 ?+1  #[ret]=-[a]
	.p0:0 .p1:0 ?+1
	.p2:0 .ret  ?+1  #[ret]=[a]
	0     0     .a4:4
#Variables
.off:2
.ret:0
.tmp:0

uint.neg:
	#Call  : 0 ? uint.neg ret a
	#Effect: [ret]=-[a]
	#Setup the stack.
	.tmp  .tmp  ?+1
	.tmp  .a2   ?+1
	0     .tmp  ?+1
	0     .off  ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	#Get [ret]
	.tmp  .tmp  ?+1
	.tmp  .a2:2 ?+1
	.p0   .p0   ?+1
	.p0   .tmp  ?+1
	.p1   .p1   ?+1
	.p1   .tmp  ?+1
	#Get [a]
	.tmp  .tmp  ?+1
	.tmp  .a3:3 ?+1
	.p2   .p2   ?+1
	.p2   .tmp  ?+1
	#Set [ret]
	.tmp  .tmp  ?+1
	.tmp  .p0:0 ?+1  #[tmp]=-[ret]
	.tmp  .p2:0 ?+1  #[tmp]=-[ret]-[a]
	.ret  .ret  ?+1
	.ret  .tmp  ?+1  #[ret]=[ret]+[a]
	.p1:0 .ret  ?+1  #[ret]=[ret]-([ret]+[a])=-[a]
	0     0     .a4:4
#Variables
.off:2
.ret:0
.tmp:0

uint.add:
	#Call  : 0 ? uint.add ret a b
	#Effect: [ret]=[a]+[b]
	#Setup the stack.
	.tmp  .tmp  ?+1
	.tmp  .a0   ?+1
	0     .tmp  ?+1
	.a0   0     ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	.a5   0     ?+1
	#Get [ret]
	.p0   .a2:2 ?+1
	.p1   .p0   ?+1
	.p2   .p0   ?+1
	.tmp  .tmp  ?+1
	.tmp  .p1   ?+1
	.p0   .p0   ?+1
	.p0   .tmp  ?+1
	#Get [a]
	.tmp  .tmp  ?+1
	.tmp  .a3:3 ?+1
	.p3   .p3   ?+1
	.p3   .tmp  ?+1
	#Get [b]
	.tmp  .tmp  ?+1
	.tmp  .a4:4 ?+1
	.p4   .p4   ?+1
	.p4   .tmp  ?+1
	#Set [ret]
	.tmp  .tmp  ?+1
	.tmp  .p3:0 ?+1  #[tmp]=-[a]
	.tmp  .p4:0 ?+1  #[tmp]=-[a]-[b]
	.p0:0 .p1:0 ?+1
	.p2:0 .tmp  ?+1  #[ret]=[a]+[b]
	#Return
	0     0     .a5:5
#Variables
.a0:0
.tmp:0
.pt:0

uint.sub:
	#Call  : 0 ? uint.sub ret a b
	#Effect: [ret]=[a]-[b]
	#Setup the stack.
	.tmp  .tmp  ?+1
	.tmp  .a0   ?+1
	0     .tmp  ?+1
	.a0   0     ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	.a5   0     ?+1
	#Get [ret]
	.tmp  .tmp  ?+1
	.tmp  .a2:2 ?+1
	.p0   .p0   ?+1
	.p0   .tmp  ?+1
	.p1   .p1   ?+1
	.p1   .tmp  ?+1
	#Get [a]
	.tmp  .tmp  ?+1
	.tmp  .a3:3 ?+1
	.p2   .p2   ?+1
	.p2   .tmp  ?+1
	#Get [b]
	.tmp  .tmp  ?+1
	.tmp  .a4:4 ?+1
	.p3   .p3   ?+1
	.p3   .tmp  ?+1
	#Set [ret]
	.tmp  .tmp  ?+1
	.tmp  .p0:0 ?+1  #[tmp]=-[ret]
	.tmp  .p3:0 ?+1  #[tmp]=-[ret]-[b]
	.ret  .ret  ?+1
	.ret  .p2:0 ?+1  #[ret]=-[a]
	.ret  .tmp  ?+1  #[ret]=[ret]-[a]+[b]
	.p1:0 .ret  ?+1  #[ret]=[a]-[b]
	#Return
	0     0     .a5:5
#Variables
.a0:0
.ret:0
.tmp:0

uint.mul:
	#Call  : 0 ? uint.mul high low a b
	#Effect:
	#     [high]=([a]*[b])/2^64
	#     [low] =([a]*[b])%2^64
	#Setup stack pointer.
	.tmp  .tmp  ?+1
	.tmp  .a0   ?+1
	0     .tmp  ?+1
	.a0   0     ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	.a5   0     ?+1
	.a6   0     ?+1
	#Get high.
	.tmp  .tmp  ?+1
	.tmp  .a2:2 ?+1
	.r0   .r0   ?+1
	.r0   .tmp  ?+1
	.r1   .r1   ?+1
	.r1   .tmp  ?+1
	#Get low.
	.tmp  .tmp  ?+1
	.tmp  .a3:3 ?+1
	.r2   .r2   ?+1
	.r2   .tmp  ?+1
	.r3   .r3   ?+1
	.r3   .tmp  ?+1
	#Get [a]. Use -[a] for adding to [rl].
	.tmp  .tmp  ?+1
	.tmp  .a4:4 ?+1
	.p0   .p0   ?+1
	.p0   .tmp  ?+1
	.a    .a    ?+1
	.a    .p0:0 ?+1
	#Get [b].
	.tmp  .tmp  ?+1
	.tmp  .a5:5 ?+1
	.p1   .p1   ?+1
	.p1   .tmp  ?+1
	.tmp  .tmp  ?+1
	.tmp  .p1:0 ?+1
	.b    .b    ?+1
	.b    .tmp  ?+1
	#Init rl and rh.
	.rh   .rh   ?+1
	.rl   .rl   ?+1
	#If [a]=0 or [b]=0, abort.
	.a    .z    .ret
	.b    .z    .ret
	#We can left shift [rh] and [rl] for the first loop.
	.rl   .z-1  ?+1
	.i    .bits .nocarry0
.loop:
	.i    .z+1  .ret
	#Left shift [rh] and [rl], don't decrement [rl] for when we add [a] to [rl].
	.tmp  .rh   ?+1
	.rh   .tmp  ?+1
	.tmp  .tmp  ?+1
	.tmp  .rl   ?+1
	.tmp  .z+1  ?+1
	.rl   .tmp  .nocarry0
	.rh   .z-1  ?+1
.nocarry0:
	.tmp  .tmp  ?+1
	#If the highest bit of [b] is set, add [a] to [rl] and carry to [rh].
	.tmp  .b    ?+1
	.tmp  .z+1  ?+1
	.b    .tmp  .nocarry1
	.rl   .a    .nocarry1
	.rh   .z-1  ?+1
.nocarry1:
	.rl   .z+1  ?+1
	.tmp  .tmp  .loop
.ret:
	#Set [high].
	.rh   .r0:0 ?+1
	.tmp  .tmp  ?+1
	.tmp  .rh   ?+1
	.r1:0 .tmp  ?+1
	#Set [low].
	.rl   .r2:0 ?+1
	.tmp  .tmp  ?+1
	.tmp  .rl   ?+1
	.r3:0 .tmp  ?+1
	0     0     .a6:6
#Variables
.tmp:0
.a0:0
.a:0
.b:0
.rh:0
.rl:0
.i:0
.bits:0-64
0-1 .z:0 1

uint.div:
	#Call  : 0 ? uint.div quot rem num den
	#Effect:
	#     [quot]=[num]/[den], rounded down
	#     [rem] =[num]%[den]
	#Setup stack pointer.
	.tmp  .tmp  ?+1
	.tmp  .a0   ?+1
	0     .tmp  ?+1
	.a0   0     ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	.a5   0     ?+1
	.a6   0     ?+1
	#Get quotient.
	.tmp  .tmp  ?+1
	.tmp  .a2:2 ?+1
	.r0   .r0   ?+1
	.r0   .tmp  ?+1
	.r1   .r1   ?+1
	.r1   .tmp  ?+1
	#Get remainder.
	.tmp  .tmp  ?+1
	.tmp  .a3:3 ?+1
	.r2   .r2   ?+1
	.r2   .tmp  ?+1
	.r3   .r3   ?+1
	.r3   .tmp  ?+1
	#Get numerator.
	.tmp  .tmp  ?+1
	.tmp  .a4:4 ?+1
	.p0   .p0   ?+1
	.p0   .tmp  ?+1
	.tmp  .tmp  ?+1
	.tmp  .p0:0 ?+1
	.num  .num  ?+1
	.num  .tmp  ?+1
	#Get denominator.
	.tmp  .tmp  ?+1
	.tmp  .a5:5 ?+1
	.p1   .p1   ?+1
	.p1   .tmp  ?+1
	.nden .nden ?+1
	.nden .p1:0 ?+1
	.den  .den  ?+1
	.den  .nden ?+1
	#If [den]=0, abort
	.den  .z    .divz
	.tmp  .tmp  ?+1
	.rem  .rem  ?+1
	.i    .bits ?+1
.loop:
	.i    .z+1  .ret
	#[quot]<<=1
	.tmp  .quot ?+1
	.quot .tmp  ?+1
	#[rem]<<=1
	.tmp  .tmp  ?+1
	.tmp  .rem  ?+1
	.rem  .tmp  ?+1
	#[rem]+=[num]>>63, [num]<<=1
	.tmp  .tmp  ?+1
	.tmp  .num  ?+1
	.tmp  .z+1  ?+1
	.num  .tmp  .nocarry
	.rem  .z-1  ?+1
.nocarry:
	#if [rem]>=[den], [quot]+=1
	.rem  .den  .noden
	.quot .z-1  .noden+6
.noden:
	.rem  .z    .noden-3
	.rem  .nden ?+1
	.tmp  .tmp  .loop
.ret:
	#Set quotient.
	.quot .r0:0 ?+1
	.tmp  .tmp  ?+1
	.tmp  .quot ?+1
	.r1:0 .tmp  ?+1
	#Set remainder.
	.rem  .r2:0 ?+1
	.tmp  .tmp  ?+1
	.tmp  .rem  ?+1
	.r3:0 .tmp  ?+1
	0     0     .a6:6
.divz:
	#Abort.
	0-1 0 0
.a0:0
.num:0
.den:0
.nden:0
.quot:0
.rem:0
.tmp:0
.i:0
.bits:0-65
0-1 .z:0 1

#--------------------------------------------------------------------------------
#Bitwise Arithmetic

uint.shl:
	#Call  : 0 ? uint.shl ret a s
	#Effect: [ret]=[a]<<[s]
	#Setup stack pointer.
	.z    .a0   ?+1
	0     .z    ?+1
	.z    .z    ?+1
	.a0   0     ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	.a5   0     ?+1
	#Get ret.
	.z    .a2:2 ?+1
	.r0   .r0   ?+1
	.r0   .z    ?+1
	.r1   .r1   ?+1
	.r1   .z    ?+1
	.z    .z    ?+1
	#Get [a]
	.z    .a3:3 ?+1
	.p0   .p0   ?+1
	.p0   .z    ?+1
	.z    .z    ?+1
	.a    .a    ?+1
	.a    .p0:0 ?+1  #[a]=-[a]
	#Get [s]
	.z    .a4:4 ?+1
	.p1   .p1   ?+1
	.p1   .z    ?+1
	.z    .z    ?+1
	.z    .p1:0 ?+1
	.s    .s    ?+1
	.s    .z    ?+1
	.z    .z    ?+1
	#If [s]<64.
	.s    .bits0 ?+4
	.a    .a     .ret
	.s    .bits1 ?+1
.loop:
	.s    .z+1  .ret
	.z    .a    ?+1
	.a    .z    ?+1
	.z    .z    .loop
.ret:
	#Set [ret].
	.z    .r0:0 ?+1
	.a    .z    ?+1
	.r1:0 .a    ?+1
	.z    .z    ?+1
	0     0     .a5:5
#Variables
.a:0
.s:0
.bits0:64
.bits1:0-65
.a0:0
.z:0 1

uint.shr:
	#Call  : 0 ? uint.shr ret a s
	#Effect: [ret]=[a]>>[s]
	#Setup stack pointer.
	.z    .a0   ?+1
	0     .z    ?+1
	.z    .z    ?+1
	.a0   0     ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	.a5   0     ?+1
	#Get ret
	.z    .a2:2 ?+1
	.r0   .r0   ?+1
	.r0   .z    ?+1
	.r1   .r1   ?+1
	.r1   .z    ?+1
	.z    .z    ?+1
	.r    .r    ?+1
	#Get [a]
	.z    .a3:3 ?+1
	.p0   .p0   ?+1
	.p0   .z    ?+1
	.z    .z    ?+1
	.z    .p0:0 ?+1
	.a    .a    ?+1
	.a    .z    ?+1
	.z    .z    ?+1
	#Get [s]
	.z    .a4:4 ?+1
	.p1   .p1   ?+1
	.p1   .z    ?+1
	.z    .z    ?+1
	.s    .s    ?+1
	.s    .bits ?+1
	#If [s]>=64.
	.s    .p1:0 .ret
.loop:
	.z    .a    ?+1
	.z    .z+1  ?+1
	.a    .z    ?+4
	.r    .z-1  ?+1
	.z    .z    ?+1
	.s    .z+1  .ret
	.z    .r    ?+1
	.r    .z    ?+1
	.z    .z    .loop
.ret:
	#Set [ret].
	.r    .r0:0 ?+1
	.z    .r    ?+1
	.r1:0 .z    ?+1
	.z    .z    ?+1
	0     0     .a5:5
#Variables
.a:0
.r:0
.s:0
.bits:0-64
.a0:0
0-1 .z:0 1

uint.not:
	#Call  : 0 ? uint.not ret a
	#Effect: [ret]=~[a]
	#Use the relation -1-[a]=~[a]
	#Setup the stack.
	.tmp  .tmp  ?+1
	.tmp  .a2   ?+1
	0     .tmp  ?+1
	0     .z+2  ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	#Get [ret]
	.tmp  .tmp  ?+1
	.tmp  .a2:2 ?+1
	.p0   .p0   ?+1
	.p0   .tmp  ?+1
	.p1   .p1   ?+1
	.p1   .tmp  ?+1
	#Get [a]
	.tmp  .tmp  ?+1
	.tmp  .a3:3 ?+1
	.p2   .p2   ?+1
	.p2   .tmp  ?+1
	#Set [ret]
	.tmp  .tmp  ?+1
	.tmp  .p0:0 ?+1  #[tmp]=-[ret]
	.tmp  .p2:0 ?+1  #[tmp]=-[ret]-[a]
	.tmp  .z+1  ?+1
	.ret  .ret  ?+1
	.ret  .tmp  ?+1  #[ret]=[ret]+[a]
	.p1:0 .ret  ?+1  #[ret]=[ret]-([ret]+[a])=-[a]
	0     0     .a4:4
#Variables
.z:0 1 2
.ret:0
.tmp:0

uint.and:
	#Call  : 0 ? uint.and ret a b
	#Effect: [ret]=[a]&[b]
	#Setup stack pointer.
	.at   .at   ?+1
	.at   .a0   ?+1
	0     .at   ?+1
	.a0   0     ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	.a5   0     ?+1
	#Get [r]
	.at   .at   ?+1
	.at   .a2:2 ?+1
	.r0   .r0   ?+1
	.r0   .at   ?+1
	.r1   .r1   ?+1
	.r1   .at   ?+1
	#Get [a]
	.at   .at   ?+1
	.at   .a3:3 ?+1
	.p0   .p0   ?+1
	.p0   .at   ?+1
	.a    .a    ?+1
	.a    .z+1  ?+1
	.a    .p0:0 ?+1
	#Get [b]
	.at   .at   ?+1
	.at   .a4:4 ?+1
	.p1   .p1   ?+1
	.p1   .at   ?+1
	.b    .b    ?+1
	.b    .z+1  ?+1
	.b    .p1:0 ?+1
	#Loop 64 times.
	.at   .at   ?+1
	.i    .bits ?+1
.loop:
	.i    .z+1  .ret
	#Prepare [a] for shift and carry.
	.at   .a    ?+1
	.at   .z+1  ?+1
	#Prepare [b] for shift and carry.
	.bt   .bt   ?+1
	.bt   .b    ?+1
	.bt   .z+1  ?+1
	#Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	      .a .at  .f0x
	.f1x: .b .bt  .f10
	.f11: .a .z+1 ?+1 .at .at .loop
	.f10: .a .z+1 ?+1 .at .at .loop
	.f0x: .b .bt  .f00
	.f01: .a .z+1 ?+1 .at .at .loop
	.f00: .a .z+0 ?+1 .at .at .loop
.ret:
	.a    .r0:0 ?+1
	.at   .a    ?+1
	.r1:0 .at   ?+1
	0 0 .a5:5
#Variables
.a:0 .at:0
.b:0 .bt:0
.i:0
.a0:0
.bits:0-65
0-1 .z:0 1

uint.or:
	#Call  : 0 ? uint.or ret a b
	#Effect: [ret]=[a]|[b]
	#Setup stack pointer.
	.at   .at   ?+1
	.at   .a0   ?+1
	0     .at   ?+1
	.a0   0     ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	.a5   0     ?+1
	#Get [r]
	.at   .at   ?+1
	.at   .a2:2 ?+1
	.r0   .r0   ?+1
	.r0   .at   ?+1
	.r1   .r1   ?+1
	.r1   .at   ?+1
	#Get [a]
	.at   .at   ?+1
	.at   .a3:3 ?+1
	.p0   .p0   ?+1
	.p0   .at   ?+1
	.a    .a    ?+1
	.a    .z+1  ?+1
	.a    .p0:0 ?+1
	#Get [b]
	.at   .at   ?+1
	.at   .a4:4 ?+1
	.p1   .p1   ?+1
	.p1   .at   ?+1
	.b    .b    ?+1
	.b    .z+1  ?+1
	.b    .p1:0 ?+1
	#Loop 64 times.
	.at   .at   ?+1
	.i    .bits ?+1
.loop:
	.i    .z+1  .ret
	#Prepare [a] for shift and carry.
	.at   .a    ?+1
	.at   .z+1  ?+1
	#Prepare [b] for shift and carry.
	.bt   .bt   ?+1
	.bt   .b    ?+1
	.bt   .z+1  ?+1
	#Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	      .a .at  .f0x
	.f1x: .b .bt  .f10
	.f11: .a .z+1 ?+1 .at .at .loop
	.f10: .a .z+0 ?+1 .at .at .loop
	.f0x: .b .bt  .f00
	.f01: .a .z+0 ?+1 .at .at .loop
	.f00: .a .z+0 ?+1 .at .at .loop
.ret:
	.a    .r0:0 ?+1
	.at   .a    ?+1
	.r1:0 .at   ?+1
	0 0 .a5:5
#Variables
.a:0 .at:0
.b:0 .bt:0
.i:0
.a0:0
.bits:0-65
0-1 .z:0 1

uint.xor:
	#Call  : 0 ? uint.xor ret a b
	#Effect: [ret]=[a]^[b]
	#Setup stack pointer.
	.at   .at   ?+1
	.at   .a0   ?+1
	0     .at   ?+1
	.a0   0     ?+1
	.a2   0     ?+1
	.a3   0     ?+1
	.a4   0     ?+1
	.a5   0     ?+1
	#Get [r]
	.at   .at   ?+1
	.at   .a2:2 ?+1
	.r0   .r0   ?+1
	.r0   .at   ?+1
	.r1   .r1   ?+1
	.r1   .at   ?+1
	#Get [a]
	.at   .at   ?+1
	.at   .a3:3 ?+1
	.p0   .p0   ?+1
	.p0   .at   ?+1
	.a    .a    ?+1
	.a    .z+1  ?+1
	.a    .p0:0 ?+1
	#Get [b]
	.at   .at   ?+1
	.at   .a4:4 ?+1
	.p1   .p1   ?+1
	.p1   .at   ?+1
	.b    .b    ?+1
	.b    .z+1  ?+1
	.b    .p1:0 ?+1
	#Loop 64 times.
	.at   .at   ?+1
	.i    .bits ?+1
.loop:
	.i    .z+1  .ret
	#Prepare [a] for shift and carry.
	.at   .a    ?+1
	.at   .z+1  ?+1
	#Prepare [b] for shift and carry.
	.bt   .bt   ?+1
	.bt   .b    ?+1
	.bt   .z+1  ?+1
	#Left shift [a] and [b] and check for carry. Set low bit of [a] if needed.
	      .a .at  .f0x
	.f1x: .b .bt  .f10
	.f11: .a .z+1 ?+1 .at .at .loop
	.f10: .a .z+0 ?+1 .at .at .loop
	.f0x: .b .bt  .f00
	.f01: .a .z+0 ?+1 .at .at .loop
	.f00: .a .z+1 ?+1 .at .at .loop
.ret:
	.a    .r0:0 ?+1
	.at   .a    ?+1
	.r1:0 .at   ?+1
	0 0 .a5:5
#Variables
.a:0 .at:0
.b:0 .bt:0
.i:0
.a0:0
.bits:0-65
0-1 .z:0 1

#|==============================================================================

String Printing - v1.00

Author: Alec Dee - alecdee.github.io - akdee144@gmail.com

--------------------------------------------------------------------------------
ASCII Table

  0  00  NUL |  26  1a      |  52  34   4  |  78  4e   N  | 104  68   h
  1  01      |  27  1b  ESC |  53  35   5  |  79  4f   O  | 105  69   i
  2  02      |  28  1c      |  54  36   6  |  80  50   P  | 106  6a   j
  3  03      |  29  1d      |  55  37   7  |  81  51   Q  | 107  6b   k
  4  04      |  30  1e      |  56  38   8  |  82  52   R  | 108  6c   l
  5  05      |  31  1f      |  57  39   9  |  83  53   S  | 109  6d   m
  6  06      |  32  20  SPC |  58  3a   :  |  84  54   T  | 110  6e   n
  7  07  BEL |  33  21   !  |  59  3b   ;  |  85  55   U  | 111  6f   o
  8  08  BCK |  34  22   "  |  60  3c   <  |  86  56   V  | 112  70   p
  9  09  TAB |  35  23   #  |  61  3d   =  |  87  57   W  | 113  71   q
 10  0a  LF  |  36  24   $  |  62  3e   >  |  88  58   X  | 114  72   r
 11  0b  VTB |  37  25   %  |  63  3f   ?  |  89  59   Y  | 115  73   s
 12  0c      |  38  26   &  |  64  40   @  |  90  5a   Z  | 116  74   t
 13  0d  CR  |  39  27   '  |  65  41   A  |  91  5b   [  | 117  75   u
 14  0e      |  40  28   (  |  66  42   B  |  92  5c   \  | 118  76   v
 15  0f      |  41  29   )  |  67  43   C  |  93  5d   ]  | 119  77   w
 16  10      |  42  2a   *  |  68  44   D  |  94  5e   ^  | 120  78   x
 17  11      |  43  2b   +  |  69  45   E  |  95  5f   _  | 121  79   y
 18  12      |  44  2c   ,  |  70  46   F  |  96  60   `  | 122  7a   z
 19  13      |  45  2d   -  |  71  47   G  |  97  61   a  | 123  7b   {
 20  14      |  46  2e   .  |  72  48   H  |  98  62   b  | 124  7c   |
 21  15      |  47  2f   /  |  73  49   I  |  99  63   c  | 125  7d   }
 22  16      |  48  30   0  |  74  4a   J  | 100  64   d  | 126  7e   ~
 23  17      |  49  31   1  |  75  4b   K  | 101  65   e  | 127  7f  DEL
 24  18  CAN |  50  32   2  |  76  4c   L  | 102  66   f  |
 25  19      |  51  33   3  |  77  4d   M  | 103  67   g  |
|#

0 0 print.test

print:
	#Call: 0 ? print char0 char1 char2 ... 0
	#Print function. Prints a zero terminated ascii string. If -1 is used as a
	#character value, then treat the next character as a pointer to a number.
	.ptr  .ptr   ?+1
	.ptr  0      ?+1
	.ptr  .z-2   ?+1
	0     0      ?+2
	.ret: .tmp
.loop:
	#Get the next character.
	.tmp  .ptr:0 ?+1
	.ptr  .z-1   ?+1
	.char .char  ?+1
	.char .tmp   .p0:?+1
	#If [char]=0, we've reached the end of the string.
	.char .z     .ret
	#If [char]>0, and [tmp]<=1, then [char]=-1.
	.tmp  .z+1   .numprep
	#Print [char].
.print:
	0-1   .char  1
	.tmp  .tmp   .loop
.numprep:
	#Prepare to print a number.
	#First entry. Jump back to beginning of loop to get the number's pointer.
	.p0   .pset  .loop
	#Second entry. Get the number from [char].
	.p0   .prem  ?+1
	.tmp  .tmp   ?+1
	.tmp  .char:0 ?+1
	.num  .tmp   ?+1
	.show .show  ?+1
	.base .base0 ?+1
.numloop:
	#Store a power of 10 in [tmp].
	.tmp  .tmp   ?+1
	.tmp  .base:.base10+19 ?+1
	.char .char  ?+1
	.char .char0 ?+1
	#Subtract [tmp] from [num] to get the next digit.
.digitloop:
	.num  .tmp   .digitdone
	.num  .z+1   ?+1
	.show .z-1   ?+1
	.char .z-1   .digitloop
.digitdone:
	#If [tmp]=0 then return to the main loop and print the last digit.
	.tmp  .z     .print
	#Add [num]+=[tmp] to correct for the last [num]-[tmp] operation.
	.z    .tmp   ?+1
	.num  .z     ?+1
	.z    .z     ?+1
	#If [show]>0, then we can print digits.
	.show .z     .noshow
	0-1   .char  1
.noshow:
	.base .z-1   .numloop
#Contants.
0-2 0-1 .z:0 1
.num:0
.tmp:0
.show:0
.char0:0-48
.base0:19
.pset:.p0-.numprep-2
.prem:.numprep-.p0+2
#1-10^n
.base10:
	0-9999999999999999999 0-999999999999999999 0-99999999999999999
	   0-9999999999999999    0-999999999999999    0-99999999999999
	      0-9999999999999       0-999999999999       0-99999999999
	         0-9999999999          0-999999999          0-99999999
	            0-9999999             0-999999             0-99999
	               0-9999                0-999                0-99
	                  0-9                    0

print.test:
	#Testing string printing\n
	0 ? print 84 101 115 116 105 110 103 32 115 116 114 105 110
		     103 32 112 114 105 110 116 105 110 103 10 0
	#a = [a]\n
	0 ? print  97 32 61 32 0-1 .a 10 0
	#b = [b]\n
	0 ? print  98 32 61 32 0-1 .b 10 0
	#c = [c]\n
	0 ? print  99 32 61 32 0-1 .c 10 0
	#d = [d]\n
	0 ? print 100 32 61 32 0-1 .d 10 0
	#[a], [b], [c], [d]
	0 ? print 0-1 .a 44 32 0-1 .b 44 32 0-1 .c 44 32 0-1 .d 0
	#\n
	0 ? print 10 0
	0-1 0 0
.a:0
.b:10
.c:1000
.d:0-1

