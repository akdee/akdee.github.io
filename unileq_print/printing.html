<!DOCTYPE HTML>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Unileq - Printing Text and Numbers</title>
	<link rel="stylesheet" href="../style/style.css" type="text/css">
	<script type="text/javascript" src="../style/style.js"></script>
</head>
<body>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Header ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div id="header"><a href="../index.html">Alec Dee's Homepage</a></div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Printing ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>Printing</h1>
<p>In the introduction to unileq, we showed how to perform several higher level operations, like
comparing values. Even though we can perform these useful operations, we may need to write out
dozens of unileq instructions to do so. Rewriting these instructions every time we need them is both
messy and error prone. To fix this, we will introduct a function calling convention that will allow
us to make use of complex operations with very little writing on our part.</p>
<br>
<p>We would also like to know what the program is doing at any given time. In particular, we would
like to be able to easily print out messages and variable values to the screen.</p>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Unileq Architecture ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>Unileq Architecture</h1>
<div class="consoleblock">  0  00  NUL |  26  1a      |  52  34   4  |  78  4e   N  | 104  68   h
  1  01      |  27  1b  ESC |  53  35   5  |  79  4f   O  | 105  69   i
  2  02      |  28  1c      |  54  36   6  |  80  50   P  | 106  6a   j
  3  03      |  29  1d      |  55  37   7  |  81  51   Q  | 107  6b   k
  4  04      |  30  1e      |  56  38   8  |  82  52   R  | 108  6c   l
  5  05      |  31  1f      |  57  39   9  |  83  53   S  | 109  6d   m
  6  06      |  32  20  SPC |  58  3a   :  |  84  54   T  | 110  6e   n
  7  07  BEL |  33  21   !  |  59  3b   ;  |  85  55   U  | 111  6f   o
  8  08  BCK |  34  22   "  |  60  3c   &lt;  |  86  56   V  | 112  70   p
  9  09  TAB |  35  23   #  |  61  3d   =  |  87  57   W  | 113  71   q
 10  0a  LF  |  36  24   $  |  62  3e   &gt;  |  88  58   X  | 114  72   r
 11  0b  VTB |  37  25   %  |  63  3f   ?  |  89  59   Y  | 115  73   s
 12  0c      |  38  26   &  |  64  40   @  |  90  5a   Z  | 116  74   t
 13  0d  CR  |  39  27   '  |  65  41   A  |  91  5b   [  | 117  75   u
 14  0e      |  40  28   (  |  66  42   B  |  92  5c   \  | 118  76   v
 15  0f      |  41  29   )  |  67  43   C  |  93  5d   ]  | 119  77   w
 16  10      |  42  2a   *  |  68  44   D  |  94  5e   ^  | 120  78   x
 17  11      |  43  2b   +  |  69  45   E  |  95  5f   _  | 121  79   y
 18  12      |  44  2c   ,  |  70  46   F  |  96  60   `  | 122  7a   z
 19  13      |  45  2d   -  |  71  47   G  |  97  61   a  | 123  7b   {
 20  14      |  46  2e   .  |  72  48   H  |  98  62   b  | 124  7c   |
 21  15      |  47  2f   /  |  73  49   I  |  99  63   c  | 125  7d   }
 22  16      |  48  30   0  |  74  4a   J  | 100  64   d  | 126  7e   ~
 23  17      |  49  31   1  |  75  4b   K  | 101  65   e  | 127  7f  DEL
 24  18  CAN |  50  32   2  |  76  4c   L  | 102  66   f  |
 25  19      |  51  33   3  |  77  4d   M  | 103  67   g  |
</div>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Function Calls ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div class="content"><h1>Function Calls</h1>
<div class="codeblock langunileq">0 0 print.test

print:
	#Print function. Prints a zero terminated ascii string. If -1 is used as a
	#character value, then treat the next character as a pointer to a number.
	#Arguments: 0 ? print char0 char1 char2 ... 0
	.ptr  .ptr   ?+1
	.ptr  0      ?+1
	.ptr  .z-2   ?+1
	0     0      ?+2
	.ret: .tmp
.loop:
	#Get the next character.
	.tmp  .ptr:0 ?+1
	.ptr  .z-1   ?+1
	.char .char  ?+1
	.char .tmp   .p0:?+1
	#If [char]=0, we've reached the end of the string.
	.char .z     .ret
	#If [char]&gt;0, and [tmp]&lt;=1, then [char]=-1.
	.tmp  .z+1   .numprep
	#Print [char].
.print:
	0-1   .char  ?+1
	.tmp  .tmp   .loop
.numprep:
	#Prepare to print a number.
	#First entry. Jump back to beginning of loop to get the number's pointer.
	.p0   .pset  .loop
	#Second entry. Get the number from [char].
	.p0   .prem  ?+1
	.tmp  .tmp   ?+1
	.tmp  .char:0 ?+1
	.num  .tmp   ?+1
	.show .show  ?+1
	.base .base0 ?+1
.numloop:
	#Store a power of 10 in [tmp].
	.tmp  .tmp   ?+1
	.tmp  .base:.base10+19 ?+1
	.char .char  ?+1
	.char .char0 ?+1
	#Subtract [tmp] from [num] to get the next digit.
.digitloop:
	.num  .tmp   .digitdone
	.num  .z+1   ?+1
	.show .z-1   ?+1
	.char .z-1   .digitloop
.digitdone:
	#If [tmp]=0 then return to the main loop and print the last digit.
	.tmp  .z     .print
	#Add [num]+=[tmp] to correct for the last [num]-[tmp] operation.
	.z    .tmp   ?+1
	.num  .z     ?+1
	.z    .z     ?+1
	#If [show]&gt;0, then we can print digits.
	.show .z     .noshow
	0-1   .char  ?+1
.noshow:
	.base .z-1   .numloop
#Contants.
0-2 0-1 .z:0 1
.num:0
.tmp:0
.show:0
.char0:0-48
.base0:19
.pset:.p0-.numprep-2
.prem:.numprep-.p0+2
#1-10^n
.base10:
	0-9999999999999999999 0-999999999999999999 0-99999999999999999
	   0-9999999999999999    0-999999999999999    0-99999999999999
	      0-9999999999999       0-999999999999       0-99999999999
	         0-9999999999          0-999999999          0-99999999
	            0-9999999             0-999999             0-99999
	               0-9999                0-999                0-99
	                  0-9                    0

print.test:
	#Testing string printing\n
	0 ? print 84 101 115 116 105 110 103 32 115 116 114 105 110
		     103 32 112 114 105 110 116 105 110 103 10 0
	#a = [a]\n
	0 ? print  97 32 61 32 0-1 .a 10 0
	#b = [b]\n
	0 ? print  98 32 61 32 0-1 .b 10 0
	#c = [c]\n
	0 ? print  99 32 61 32 0-1 .c 10 0
	#d = [d]\n
	0 ? print 100 32 61 32 0-1 .d 10 0
	#[a], [b], [c], [d]
	0 ? print 0-1 .a 44 32 0-1 .b 44 32 0-1 .c 44 32 0-1 .d 0
	#\n
	0 ? print 10 0
	0 0 0-1
.a:0
.b:10
.c:1000
.d:0-1
</div>
<p>It would be nice to use the code blocks above without needing to rewrite them every time we need
them. In some assembly languages we could hide them in an assembler macro, and in high level
languages we could create a function construct. However, using a special convention, we can create
our own easy to use function calling mechanism from entirely within unileq.</p>
<br>
<p>We will continue to use the shorthand <i>[x]</i> to represent <i>mem[x]</i>, or the value at
memory address <i>x</i>. Now, assume that the label <i>func</i> is the function we want to call, and
address <i>0</i> always holds the value <i>0</i> when we begin. Then the function calling format we
will use is:</p>
<br>
<div class="codeblock langunileq">0 ? func arg0 arg1 ...</div>
<br>
<p>When the unileq instruction <i>0 ? func</i> is executed, it will perform the operation
<i>[0]=[0]-[?]</i>. Since <i>?</i> refers to the current address in memory, <i>[?]=?</i>. Also, by
our assumptions, <i>[0]=0</i>. Thus, we have <i>[0]=0-?</i>. That is, we store the negation of the
current address in memory address <i>0</i>. And since <i>0</i> will always be less than or equal to
any other value, we will always jump to <i>func</i>.</p>
<br>
<p>Now that our instruction pointer has jumped to <i>func</i>, we will want to parse the arguments
that we are passing: <i>arg0 arg1 ...</i> etc. Since we know that address <i>0</i> holds the
negative of the address of the where the function was called from, and that the arguments are listed
immediately after the calling address, we can retrieve <i>arg0</i> at <i>-[0]+2</i>, <i>arg1</i> at
<i>-[0]+3</i>, and so on.</p>
<br>
<p>In other words, using this format, we can use the memory addresses after the calling unileq
function to act as a stack and hold the arguments we want to pass to the function. Furthermore, we
will know to return to the address immediately after the arguments in order to resume program
flow.</p>
<br>
<p>The unileq program below creates a function called <i>print</i> which can be called to print a
zero terminated ascii string. For instance, we could print "ABC" using <i>0 ? print 65 66 67 0</i>.
</p>
<br>
<div class="codeblock langunileq">0 0 main  #Jump to main

print:
     #Print function. Prints a zero terminated ascii string.
     #Arguments: 0 ? print char0 char1 char2 ... 0
       .ptr   .ptr   ?+1  #Store the calling address+2 in ptr
       .ptr  .neg2   ?+1
       .ptr      0   ?+1
.loop:    0      0   ?+2  #Loop through each character
.ret:     0               #Return using "0 0 .ptr"
          0 .ptr:0   ?+1
       .ptr  .neg1   ?+1  #increment [ptr]
          0  .char  .ret  #if [0]=0, return
      .char      0   ?+1  #[char]=[[ptr]]
        0-1  .char   ?+1
      .char  .char .loop
.char:    0
.neg1:  0-1
.neg2:  0-2

main:
     #print test\n
     0 ? print 112 114 105 110 116 32 116 101 115 116 10 0

     #Hello, World!\n
     0 ? print 72 101 108 108 111 44 32 87 111 114 108 100 33 10 0

     #exit
     0 0 0-1
</div>
<br>
<p>Note the use of sublabels, such as <i>.char</i>, under the <i>print</i> label. This defines the
sublabel under the scope of the parent label and helps us avoid label name collisions in larger
unileq programs.</p>
<br>
<p>The <i>print</i> function also uses a few tricks to remain small, but with some rearranging it
might still be possible to remove an instruction from the function.</p>
</div>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Footer ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<div id="footer">Created on 9 Apr 2020 - Modified on 2 Jun 2020<br>
Questions and comments: akdee<b>OBFUS</b>144@g<b>CATE</b>mail.com<br>
<a href="../index.html">Alec Dee's Homepage</a></div>
</body>
</html>
